package tdd2go

import (
	"fmt"
	"github.com/hiveot/hub/lib/things"
	"github.com/hiveot/hub/lib/utils"
	"regexp"
)

// GenServiceClient generates a client function for invoking a Thing action.
//
// This client will marshal the API parameters into an action argument struct and
// invoke the method using the provided messaging transport.
//
// The TD document must be a digital twin received version
func GenServiceClient(l *utils.L, serviceTitle string, td *things.TD) {

	//l.Add("// %sClient client for talking to the '%s' service", serviceTitle, td.ID)
	//l.Add("type %sClient struct {", serviceTitle)
	//l.Add("   dThingID string")
	//l.Add("   hc hubclient.IHubClient")
	//l.Add("}")

	actionKeys := utils.OrderedMapKeys(td.Actions)
	for _, key := range actionKeys {
		action := td.Actions[key]
		GenActionMethod(l, serviceTitle, key, action)
	}
	l.Add("")
	//l.Add("// New%sClient creates a new client for invoking %s methods.", serviceTitle, td.Title)
	//l.Add("func New%sClient(hc hubclient.IHubClient) *%sClient {", serviceTitle, serviceTitle)
	//l.Add("	cl := %sClient {", serviceTitle)
	//l.Add("		hc: hc,")
	//l.Add("		dThingID: \"%s\",", td.ID)
	//l.Add("	}")
	//l.Add("	return &cl")
	//l.Add("}")

}

// GenActionMethod generates a client function from an action affordance.
//
// For multi-arguments the format of the generated client is:
// > func(hc hubclient.IHubClient, arg1 type, arg2 type, ...)(resp type, err error) {
// >   var args = ArgTypeNameArgs{arg1, arg2, ...}
// >   err = hc.Rpc(DThingID, MethodName, &args, &resp)
// >   return
// > }
//
//	serviceTitle  title-case thingID of the service without the agent prefix
//	key with the service action method.
//	action affordance describing the input and output parameters
func GenActionMethod(l *utils.L, serviceTitle string, key string, action *things.ActionAffordance) {
	argsString := "hc hubclient.IHubClient"
	respString := "err error"
	invokeArgs := "nil"
	invokeResp := "nil"
	// this holds lines for assigning input arguments to the arguments struct
	// the server is expecting.
	argStructLine := ""
	serviceDigitwinID := serviceTitle + "DThingID" // as defined in GenGoAPI

	methodName := serviceTitle + Key2ID(key)
	// input arguments: none, single or multiple
	if action.Input != nil {
		argName := getParamName("args", action.Input)
		goType := ""
		// client arguments are in alpha name order
		// create a list of fields from the input
		if action.Input.Type == "object" && action.Input.Properties != nil {
			// argsGoType is generated by GenActionStructs
			argsGoType := fmt.Sprintf("%sArgs", methodName)
			// list of argument names separated by comma for populating the args struct
			// the order is alphabetical so it matches that of the args struct
			argNames := ""
			// multiple arguments
			// arguments are in alphabetic order
			keys := utils.OrderedMapKeys(action.Input.Properties)
			for _, key := range keys {
				ds := action.Input.Properties[key]
				//argName := getParamName("args", ds)
				argName = key
				goType = GoTypeFromSchema(ds)
				if len(argsString) > 0 {
					argsString += ", "
				}
				if len(argNames) > 0 {
					argNames += ", "
				}
				argsString += fmt.Sprintf("%s %s", argName, goType)
				argNames += argName
			}
			argStructLine = fmt.Sprintf("var args = %s{%s}", argsGoType, argNames)
			invokeArgs = "&args"
		} else {
			// single argument
			goType = GoTypeFromSchema(action.Input)
			argsString += fmt.Sprintf(", %s %s", argName, goType)
			invokeArgs = "&" + argName
		}
	}
	// add a response struct to arguments
	if action.Output != nil {
		respName := getParamName("resp", action.Output)
		goType := ""
		if action.Output.Type == "object" && action.Output.Properties != nil {
			goType = fmt.Sprintf("%sResp", methodName)
		} else {
			goType = GoTypeFromSchema(action.Output)
		}
		respString = fmt.Sprintf("%s %s, err error", respName, goType)
		invokeResp = "&" + respName
	}
	// Function declaration
	l.Indent = 0
	l.Add("")
	l.Add("// %s client method - %s.", methodName, action.Title)
	if len(action.Description) > 0 {
		l.Add("// %s", action.Description)
	}
	l.Add("func %s(%s)(%s){", methodName, argsString, respString)
	l.Indent++

	// if the input has multiple arguments then add the Args struct
	l.Add(argStructLine)

	l.Add("err = hc.Rpc(%s, %sMethod, %s, %s)", serviceDigitwinID, methodName, invokeArgs, invokeResp)
	l.Add("return")
	l.Indent--
	l.Add("}")
}

// Generate a parameter name from the schema title.
// Parameter names start with lower case and consist only of alpha-num chars
// Intended to make the api more readable.
func getParamName(defaultName string, ds *things.DataSchema) string {
	if ds.Title == "" {
		return defaultName
	}
	str := regexp.MustCompile(`[^a-zA-Z0-9]+`).ReplaceAllString(ds.Title, "")
	str = FirstToLower(str)
	return str
}
