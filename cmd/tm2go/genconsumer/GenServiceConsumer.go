package genconsumer

import (
	"fmt"
	"github.com/hiveot/hub/cmd/tm2go/gentypes"
	"github.com/hiveot/hub/lib/utils"
	"github.com/hiveot/hub/wot"
	"github.com/hiveot/hub/wot/td"
	"regexp"
	"time"
)

// GenServiceConsumer generates a consumer function for invoking Thing actions.
//
// This consumer will marshal the API parameters into an action argument struct and
// invoke the method using the provided messaging transport.
//
// The TD document must be a digital twin received version
func GenServiceConsumer(l *utils.SL, agentID string, tdi *td.TD) error {

	serviceID := gentypes.ToTitle(tdi.ID)
	actionKeys := utils.OrderedMapKeys(tdi.Actions)
	genImports(l, agentID, serviceID)
	for _, key := range actionKeys {
		action := tdi.Actions[key]
		GenActionMethod(l, serviceID, key, action)
	}
	l.Add("")
	return nil
}

// imports needed for the agent
func genImports(l *utils.SL, agentID string, serviceID string) {

	l.Add("// Package %s with the agent request handler for using service '%s'",
		agentID, serviceID)
	l.Add("// This builds a service consumer that send a service request.")
	l.Add("// DO NOT EDIT. This file is auto generated by tm2go. Any changes will be overwritten.")
	l.Add("// Generated %s. ", time.Now().Format("02 Jan 2006 15:04 MST"))
	l.Add("package %s", agentID)

	l.Add("")
	//l.Add("import \"errors\"")
	l.Add("import \"github.com/hiveot/hub/messaging\"")
	//l.Add("import \"github.com/hiveot/hub/messaging/tputils\"")
	//l.Add("import \"github.com/hiveot/hub/messaging\"")
	l.Add("")
}

// GenActionMethod generates a client function from an action affordance.
//
// For multi-arguments the format of the generated client is:
// > func(hc hubclient.IConsumerlient, arg1 type, arg2 type, ...)(resp type, err error) {
// >   var args = ArgTypeNameArgs{arg1, arg2, ...}
// >   err = hc.Rpc(DThingID, MethodName, &args, &resp)
// >   return
// > }
//
//	serviceTitle  title-case thingID of the service without the agent prefix
//	key with the service action method.
//	action affordance describing the input and output parameters
func GenActionMethod(l *utils.SL, serviceTitle string, key string, action *td.ActionAffordance) {
	argsString := "hc *messaging.Consumer"
	respString := "err error"
	invokeArgs := "nil"
	invokeResp := "nil"
	// this holds lines for assigning input arguments to the arguments struct
	// the server is expecting.
	argStructLine := ""
	serviceDigitwinID := serviceTitle + "DThingID" // as defined in GenGoAPI

	methodName := serviceTitle + gentypes.Name2ID(key)
	// input arguments: none, single or multiple
	if action.Input != nil {
		argName := getParamName("args", action.Input)
		goType := ""
		// client arguments are in alpha name order
		// create a list of fields from the input
		if action.Input.Type == "object" && action.Input.Properties != nil {
			// argsGoType is generated by GenActionStructs
			argsGoType := fmt.Sprintf("%sArgs", methodName)
			// list of argument names separated by comma for populating the args struct
			// the order is alphabetical so it matches that of the args struct
			argNames := ""
			// multiple arguments
			// arguments are in alphabetic order
			keys := utils.OrderedMapKeys(action.Input.Properties)
			for _, key := range keys {
				ds := action.Input.Properties[key]
				//argName := getParamName("args", ds)
				argName = key
				goType = gentypes.GoTypeFromSchema(ds)
				if len(argsString) > 0 {
					argsString += ", "
				}
				if len(argNames) > 0 {
					argNames += ", "
				}
				argsString += fmt.Sprintf("%s %s", argName, goType)
				argNames += argName
			}
			argStructLine = fmt.Sprintf("var args = %s{%s}", argsGoType, argNames)
			invokeArgs = "&args"
		} else {
			// single argument
			goType = gentypes.GoTypeFromSchema(action.Input)
			argsString += fmt.Sprintf(", %s %s", argName, goType)
			invokeArgs = "&" + argName
		}
	}
	// add a response struct as output argument
	if action.Output != nil {
		respName := getParamName("resp", action.Output)
		goType := ""
		// if the output is an object with a schema then use schema as the type
		if action.Output.Type == "array" {
			// the type of an array is determined by its 'items' dataschema:
			//  when items is an object dataschema then the type is a predefined RespType
			itemsType := action.Output.ArrayItems
			if itemsType != nil && itemsType.Type == "object" && itemsType.Schema == "" {
				// this special array-of-objects case has to be handled here as the
				// type is already predefined in the Types file.
				goType = fmt.Sprintf("%sResp", methodName)
			} else {
				// otherwise use as-is
				goType = gentypes.GoTypeFromSchema(action.Output)
			}
		} else { // use a native response type
			goType = gentypes.GoTypeFromSchema(action.Output)
		}
		//}
		respString = fmt.Sprintf("%s %s, err error", respName, goType)
		invokeResp = "&" + respName
	}
	// Function declaration
	l.Indent = 0
	l.Add("")
	l.Add("// %s client method - %s.", methodName, action.Title)
	if len(action.Description) > 0 {
		l.Add("// %s", action.Description)
	}
	l.Add("func %s(%s)(%s){", methodName, argsString, respString)
	l.Indent++

	// if the input has multiple arguments then add the Args struct
	l.Add("%s", argStructLine) // go-1.24 warns about non-constant format string

	l.Add("err = hc.Rpc(\"%s\", %s, %sMethod, %s, %s)",
		wot.OpInvokeAction, serviceDigitwinID, methodName, invokeArgs, invokeResp)
	l.Add("return")
	l.Indent--
	l.Add("}")
}

// Generate a parameter name from the schema title.
// Parameter names start with lower case and consist only of alpha-num chars
// Intended to make the api more readable.
func getParamName(defaultName string, ds *td.DataSchema) string {
	if ds.Title == "" {
		return defaultName
	}
	str := regexp.MustCompile(`[^a-zA-Z0-9]+`).ReplaceAllString(ds.Title, "")
	str = gentypes.FirstToLower(str)
	return str
}
