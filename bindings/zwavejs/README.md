# ZwaveJS binding for HiveOT

This binding connects to a ZWave USB-Stick controller, and publishes events to the HiveOT message bus.

## Status

This binding is alpha and needs further testing.

TODO:

1. Nats transport javascript client
1. ZWave stick reconnect support (Recover after serial port removal)
1. Detect and track health of nodes; dropped messages, etc.
    * timeouts; dropped messages
    * list of neighbours
1. Improve mapping of zwave-js VID names to hiveot property/event/action vocabulary. A. map of vid names to vocab names in the driver, and/or B. just publish native values and manage mapping on the Hub C. define proper handling of multi-value properties
1. Include DataSchema in controller configurations for properties that aren't in the zwave-js vids.
1. Dimming duration is currently not supported

## ~~Build with pkg using tsc~~

!!! WARNING: this no longer works as it isn't compatible with ESM.

> Error [ERR_REQUIRE_ESM]: require() of ES Module node_modules/tslog/dist/cjs/index.js

old:
This needs:

* yarn
* nodejs v20+
* typescript compiler v4.9+ (tsc, included in snap's node)
* make tools
* pkg, tsc, tsc-alias, etc

Run 'yarn dist' and watch the magic unfold (...hopefully, this is a javascript build environment after all).

If all goes according to plan, a single binary is produced in the dist folder: dist/zwavejs

## Building with esbuild

This first step is just for testing the build process using esbuild. If this already fails then no use using pkg or the 'postject' node20+ injector. Note: one reason to take this step is to allow packages with es modules (axios) to work. pkg seems to not build correctly with code generated with tsc && tsc-alias.

To build the binding into a single js file:

> esbuild src/main.ts --bundle --platform=node --target=node20 --preserve-symlinks --outfile=build/zwavejs-esbuild.js

Note: to run this, 2 folders are needed in the project root: (yes not ideal but this is just for verification)

* ln -s node_modules/@serialport/bindings-cpp/prebuilds .
* ln -s node_modules/@zwave-js/config/config .

Then run from the project root with:
> ZWAVEJS_EXTERNAL_CONFIG=./dist/cache node build/zwavejs-esbuild.js --clientID testsvc --home ~/bin/hiveot/

* note1: --clientID is the client this runs under, eg 'testsvc' during testing. Default will be the binding name zwavejs.

## build a single executable using pkg and esbuild

NOTE: This uses the output of the previous esbuild step in build/zwavejs-esbuild.js and requires the prebuilds and config folder symlinks to work.

Note that vercel/pkg is deprecated. The fork from yao-pkg/pkg supports node20.

Configuration:

* pkg config is defined in package.json 'pkg' section.

Build with:
> npx pkg package.json

run it:
> dist/zwavejs --clientID testsvc --home ~/bin/hiveot

Three problems are noticeable:

1. The build generates "prebuild-install warn install No prebuilt binaries found" warnings. These seem to be okay as the serialport prebuild binaries are included as assets and will be loaded on startup.
2. The build generates "failed to make bytecode node20.11 for file ...node_modules/axios/lib/..." warning. Things seem to run fine in spite of these warnings.

TODO: To clean up this mess, lets move it all to the build directory.

## Installation

Installation needs the executable, an authentication token, and the CA certificate of the Hub.

The binding executable should be copied to the hiveot plugins folder, for example: ~/bin/hiveot/bin/plugins. The authentication token is generated by the launcher, or can be generated manually using the hubcli. The token file has the same name as the executable with the .token extension. The CA certificate is generated by the hubcli on startup and placed in certs/caCert.pem.

## Run

Before running the binding make sure the hub gateway is running. 'hubcli ls' lists the running processes.

The binding can be launched from the hubcli:
> bin/hubcli start zwavejs

To manually run the binding:
> ~/bin/hiveot/plugins/zwavejs

The binding connects to the Hub gateway using service discovery, or uses the hubURL configuration from the config/zwavejs.yaml configuration file.

On startup if a configuration file doesn't yet exist it generates a default file into hiveot/config/zwavejs.yaml. This configuration file contains all sorts of interesting settings such as the serviceID, the ZWave S2 keys, zwave controller serial port, and a few other settings. Most importantly in a conventional setup the gateway and serial port are auto-discovered, so things will just run out of the box.

If you have an existing zwave network with S2 keys then copy these keys in their hex format into the respective fields in the configuration file should let it adopt the network, in theory. This has not yet been tested.

To autostart the binding add it to the autostart section of the launcher.yaml configuration file in the config folder.

## Multiple Instances

* Note: This section is fluid.

Each binding instance on the network must have a unique serviceID. This allows for multiple zwave controllers in different areas. To run multiple instances with different service IDs rename the executable. For example to zwavejs-1, zwavejs-2, etc. The launcher generates keys and tokens for each separately. Each instance will publish the discovered Things and events under their own serviceID.

