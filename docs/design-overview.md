# HiveOT Hub Core Design Overview

## Introduction


HiveOT stands for the "Hive of Things". It provides the means to collect and share sensor data and other information with its users. 

The Hive is a network of one or more Hubs that exchange this information. A Hub can be used to collect information for a geographical location, such as a home, or warehouse, or be dedicated to collection a type of information, for example environmental sensors from multiple locations.

Each Hub is linked to a collection of information agents such as IoT devices and services. Each agent provides one or more 'Things' with IoT information. Agents connect to a Hub through a provisioning process (more on that below). The Hub handles the authentication and authorization of messages from and to the agents. 

The hearth of a Hub is the 'Digital Twin Runtime' which includes support for various transport protocols. It manages a collection of Digital Twins for connected devices. A Digital Twin is a digital replica of an actual Thing. It contains the Thing Description (TD) document and property vales reflecting the state of a Thing. Modifying a property on a Digital Twin will be passed on to the actual device. Changes to the state of the device will be send as events to the Digital Twin which will forward it to subscribers. Device agents and consumers can use any of the supported protocol bindings to connect to the Hub and publish or retrieve Thing information.

![](digitwin-overview.jpg)

*Digital Twin Runtime Overview*

Thing information is sent to the Hub by so-called 'agents'. An agent can represent any number of Things. For security reasons there is no direct connection allowed between consumers and agents. Agents can therefore remain isolated from the consumers and connect using their own protocol. An agent will send the TD documents of each of its Things to the Hub, send events when Thing state changes and will receive actions directed at one of its Things by the digital twin service. The agent itself can also provide a Thing for itself, for example to manage its configuration.  

Agents need an account on the Hub before they are allowed to send or receive Thing information. The account can be provisioned manually, through a signed certificate, or automatically using the idprov service using an out-of-bounds verification mechanism.  

Consumers typically login using username and password that are setup with the consumer's account. On successful login a consumer is issued an authentication token that is used for the actual authentication. Authentication tokens can also be issued through other identify verification means such as a client certification and (in future) oauth.   

There are several types of agents:
* An IoT device that implements the HiveOT api or protocol directly is both an agent and a Thing.
* An IoT protocol binding that bridges an existing IoT protocol to the HiveOT hub. Example bindings are for zwave, zigbee, CoAP protocols, and for external data sources such as weather stations, email, sms message and so on.
* A service that enriches information. For example, the history service provides the ability to query historical event data obtained from Things. 

Consumers are users of information. Consumers subscribe to the Hub for events from Things and publish actions to trigger an action on a Thing. The authorization to subscribe to events and publish actions depends on the role the consumer has on the Hub. The Hub predefines roles for viewers, operators, managers and administrators. Additional custom roles can be defined with fine-grained access to specific sources.

An illustration of the event flow can be found here: [Event Flow](event-flow.jpg)

An illustration of the action flow can be found here: [Action Flow](action-flow.jpg)

In addition to receiving events and publishing of actions, consumers can receive a delivery progress update of an action it sent. When a user publishes an action request, the Hub digital twin forwards it to the agent for the Thing. The agent passes it to the device and sends the response back to the digital twin, which in turn passes it on to the consumer. Only messages that the agent and user are authorized for are passed on. The benefit of this approach is that the consumer and agent can use different protocols. The downside is the extra latency.

Services combine the capabilities of agents and consumers. They can publish events and actions, receive actions, and subscribe to events through the service agent. Services authenticate using a predefined authentication token, which is generated by the launcher.
On startup, services register the roles that are allowed to invoke actions on the service. For example, the included history service requires the viewer role for sending the action to read the history and manager role to configure the history.  

Finally, the Hub digital twin runtime combines the digital twin directory, inbox and outbox services, messaging protocols, authentication and authorization, into a light-weight stand-alone runtime service. The Hub can include any number of plugins for IoT protocol bindings and supporting services such as a history service.

Last but not least, the plan is for a bridge service that supports exchange of specific IOT data with other hubs, creating a hive of things.


# Hub Transport Protocols

The Hub includes several communication protocols out of the box. Each transport protocol supports publishing of messages, receiving of messages and subscribing to events. The available transport protocols are be included in the TD document forms provided by the directory, so that consumers can invoke actions using clients that support TDD actions. Alternatively, the Hub includes a client library for various programming languages.

Initially the HTTPS/SSE transport using JWT/password authentication is supported out of the box. The return channel uses server-sent-events which is a lightweight uni-directional communication channel that runs over HTTP.

Additional transport protocols are planned:
- HTTPS using Websockets sessions  
- MQTT using pub/sub messaging server using JWT/password authentication 
- Other pub/sub message bus protocols being considered are NATS, Redis, and HiveMQT.

As all messages are routed via the hub, the hub can choose the optimal protocol to reach agent or consumer. The downside is extra latency as a message is transported twice, first to the Hub and then to the consumer or agent. The main benefit is that a consumer does not have to be aware and support the protocol used by the device agent and vice versa.

Support for additional protocols can be added as needed. Note that the hub authentication mechanism must be supported by the protocol server. This currently includes username/password, jwt tokens and certificate based authentication.

Use of external protocol servers such as Redis can be accommodated with the caveat that account management must be synchronized between the authn service and the protocol server. Client account ID must match between the server and the runtime. Use of a 3rd party authentication server such as OAuth might be supported in the future but is currently out of scope. 

### HTTPS/SSE/WS

The HTTPS/SSE/WS transport protocols open a listening TLS port for clients (both agents and consumers) to connect to. The connection handles publishing of events and actions, which are passed through the middleware and handled by the runtime as described below.

The transport configuration defines the addressing used for properties, events, actions, and the directory service. The address pattern used is that of /things/{thingID}/.... For example "/things/{thingID}/{name}. REST GET requests are used to read values while PUT requests are used to update values. Actions use a POST request to initiate an action including requesting a change in property configuration value.

These paths are included in the TD document forms, which describe how to access the values.
 
All requests must use TLS. Requests must carry a valid authentication token, except for the login request.

See the [HTTPS Binding Config](../runtime/protocols/httpsbinding/HttpsBindingConfig.go) for more details.

#### SSE

The server supports SSE sessions (Server Side Events) to notify consumers of events, and agents and services of actions.

The SSE connection path is and requires a valid session token:
* GET "/sse"

#### WebSockets (future)

A websocket server is planned. The aim is to reduce communication latency.

#### RPC 

RPC support makes it a bit easier to invoke action requests on services and obtain
a reply synchronously. The HTTPS/SSE client implements RPC support by including a messageID and wait for a delivery status messsage containing that message ID. This is implemented client side. The only requirement is that the agent that receives the action sends a delivery status event containing the same message ID. The digitwin inbox intercepts the delivery status event events and forwards it to the consumer that sent the action request. 

### MQTT (in development)

MQTT and other message bus protocols support publish and subscribe sessions natively. The message bus server must integrate with the hub's authentication and authorization services to ensure property security.

Topic rules must not allow direct messaging between consumers and agents that are connected on the bus. This is managed through the use of topics with a different prefix for hub, consumers and agents.

Below a description of the topics used when passing messages between consumer, hub and agent.

Event Flow:
The event flow passes events published by Thing agents to the hub outbox. These events apply to Things managed by the agent. Once the hub receives an event it changes the thing-ID to that of the digital twin and stores it in the outbox. The outbox passes it on to the message bus transport which in turn publishes it to subscribers. 

1. Agent -> Hub
   Agent PUB: "event/{agentID}/{thingID}/{name}" 
   Hub SUB:   "event/+/+/#"
   * The Hub is authorized to listen to events from all agents

2. Hub -> Consumer  (sender is the hub, dThingID is the digital twin's thingID)
   Hub PUB:      "event/{hubID}/{dThingID}/{name}"
   Consumer SUB: "event/{hubID}/{dThingID}/{name}"
   * The Hub is authorized to publish events on its own ID. The events contain the digital twin ThingID, instead of the agent provided thing-ID.
   * Consumers are authorized to subscribe to hub events depending on their role. 

Action Flow:  (for property updates substitute "action" for "property")
1. Consumer -> Hub (consumer publish actions to a digital twin Thing)
   Consumer PUB:  "action/{hubID}/{dThingID}/{name}/{consumerID}"
   Hub SUB:       "action/{hubID}/+/+/#"
   * Consumers are only allowed to publish actions to {hubID} 
   * The Hub subscribes to action requests made by consumers that are directed to the hub.
   * The Hub stores action requests in its inbox, to be delivery when the agent is available.
   
2. Hub -> Agent (sender is hub)
   Hub PUB:   "action/{agentID}/{thingID}/{name}/{hubID}
   Agent SUB: "action/{agentID}/+/+/#"
   * The Hub publishes actions to the agent.
   * Action requests are send in the order they arrive.
   * Agents are authorized to subscribe to actions for their own agentID prefix.
   * The Hub is allowed to publish actions for all agents


## Hub Clients

Each transport protocol server includes a client that implements the IHubClient interface. These clients can be used for agents, services and consumers.

The Hub client implementations are for convenience. Each implementation supports methods for authentication, publishing events, TDs, and action requests, subscribing to events, and set handlers for receiving events and action requests.

Use of this client is optional as consumers can use the TD forms to decide the protocol to use for invoke an action and subscribe to events. 

For convenience, client libraries are provided in Golang, Javascript and Python. (in development)

### ConsumedThing

Consumers can use the ConsumedThing output to read properties and events, and send action requests.

A problem is that the WoT specification does not describe how to link writing properties or requesting actions to the events that signal the result of these requests. This is required to track the progress of actions and to display the last result of an action. Below is the HiveOT implementation of action tracking.

WoT specifies an optional action output schema. How is this output delivered? using SSE/WS/MQTT definition in the Forms section? As the output isn't standardized how to generalize tracking of request progress? Also, seems more aimed and return result values rather than tracking progress. 

Some options to consider:
1. Define a 'delivery' event with the same message ID as the action or property change request. 
   - pro: can track continuous updates of a request (opening/closing valves, blinds etc)
   - pro: can cancel actions using the messageID (or is this a separate action?) 
   - con: WoT doesn't specify how to include message IDs in actions and events. This needs support for a 'message envelope'.
2. Link events by their key to that of corresponding action or property key.  
   - pro: use existing data types
   - con: can't link event instance to action instance (no messageID)
   - con: define events for every single property/action???

Question: Is the use of a message envelope with messageID a good way to track progress?
There are two issues here: tracking of request delivery and tracking of request processing and result. Tracking delivery is a transport problem. Can they be combined?

- Are message envelopes always available on all transports? 
  - Not without a specification that requires it.

Proposal:
1. Define message envelopes in the TD using Forms. This requires some 'creative' specifications.
  - All responses contain a messageID
2. A message envelope can be defined top-level in the TD. no need to specify this for each interaction affordance.
3. In HiveOT InteractionAffordances don't use forms (they are empty). Instead, top level specified messages are used for subscribing to events, writing properties and requesting actions. 
4. Standardize a 'delivery' event containing delivery progress and possible output value as per schema defined in the property/action affordance, linked to the request by the messageID. 

Write up a proper proposal for this and publish on the forum. Just to see what other ideas are out there.

# Security

Security is a first-class multi-layered feature of HiveOT.  
The first layer of protection is provided by simply not allowing direct connections between consumers and IoT device agents. Instead, agents and consumers authenticate and connect to the Hub and send their messages to the Digital Twin Runtime who routes the message. 

The second layer of protection is provided by 'requiring' that IoT device agents do not listen on any network ports, unless this is required for their functionality. Instead, agents connect to the Hub as a client.
For 3rd party IoT devices that do not support HiveOT rules, a protocol binding service can provide a bridge between device and the Hub, allowing the IoT device to be placed on a separate secured network segment or behind a firewall.

The third layer of protection is the using of short-lived JWT authentication tokens for consumers, that are linked to their session. If a valid token is obtained by another client then it cannot be used as each connection has its own session. Tokens expire within weeks. Consumers must reconnect before expiry to refresh their token, or login with their password again. This is a consumer facing security. Services and agents usee a single persistent session but are still required to periodically refresh their authentication token.

The fourth layer of protection is provided through role based authorization. Consumers are only able to access Things based on their role. A viewer role does not allow sending actions to Things for example.

Middleware adds additional protection against abuse by include rate control and optionally additional security checks. (this is still under development)


## Connectivity and Authentication

By default, all connections require TLS to ensure encrypted communication.

Out of the box, the hub uses a self-signed certificate. For local this can be sufficient as long as consumers have access to the CA certificate. Support for lets-encrypt is planned for the future.

The Hub supports multiple forms of connection authentication depending on the communication protocol used. As a minimum a login/password, JWT token and pub/private key authentication are supported.

All users must be known to the Hub before they can connect with their credentials. Future consideration is the use of 3rd party auth providers.  

Authentication is managed through the embedded 'authn' service. 

## Authorization

Authorization determines which clients can subscribe to events and publish actions based on their role. This is controlled by the authorization service. 

### Agent Authorization

Each agent is only allowed to publish on their own behalf.

Agents connect to the Hub and have permissions to publish events with IoT data and receive action requests directed at things managed by the agent. 

Agents are authorized to:
  * publish a TD document for each of the Things it manages.
  * publish events for the Things it manages.
  * receive action request directed at things they manage. 

The Thing-ID's used by the agent is simply that reported by the Thing itself. When publishing a TD and events, the digital twin services modifies the thingID to a digital-twin thingID (dThingID) that combines the agentID and the thingID into 'dtw:{agentID}:{thingID}'. When consumers read the Thing directory they will obtain the digital twin version of a Thing containing the digitwin ThingID. The agent for these Things is the Hub.

On startup, agents can register their own set of rules with the roles that are allowed to use the things or services they offer. By default the general roles apply.

### Consumer Authorization

Consumers are clients that subscribe to events and publish actions. Consumers have a role that determines whether they are allowed to publish messages containing actions and configuration properties. For simplicity consumers only have a single role on a hub. Predefined consumer roles are viewer, operator, manager, and admin.

Consumers with the viewer and higher roles role can subscribe to events published by IoT agents.  

Consumers with operator roles can publish Thing actions.

Consumers with manager role can publish Thing actions and Thing properties to configure Things.

Consumers with the admin role has the same permissions as the manager and can in addition use services that require the admin role. Each service sets the roles that are allowed or denied its use. See the documentation of the authz service for details.


#### Service Authorization

Services can play three different roles: that of an agent, a consumer, a service provider, or a combination of these.

Just like IoT devices, services are connected through agents. The agent publishes a TDD for each service that describes the supported methods actions. 

Example services are the digitwin directory, inbox, outbox, history store, state store, launcher, and provisioning services. Services methods are invoked by sending an action to the corresponding service dThingID.

Service agents use the authorization service to configure a set of rules describing what roles can invoke actions on the service. For example, a client with the admin role can configure the history store while operators are not allowed to invoke these methods, even though the standard rules allow both roles to publish property configuration. If no rules are defined than the standard roles apply.

The 'authz' authorization service is included within the hub runtime and consists of two services: administration and a user services. The administration service supports actions to manage roles while the user service lets a service agent set the permissions required to send actions to the service.

The authz agent therefore has two distinct capabilities, authorizing incoming messages and secondly, offering an API to manage the service. See the [authz TDD directory](../runtime/authz/tdd) for more details.


### Custom Roles (future consideration)

As described above, each role defines the allowed publish and subscribe addresses allowed by that role.

Custom roles allow fine-grained configuration of what sources and services the role can publish and subscribe to.

Custom roles can be used to provide more fine-grained permissions to consumers based on a specific use-case.

This is a future consideration.

