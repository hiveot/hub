# Hive Of Things on NATS

HiveOT provides a platform for receiving, processing and delivery of IoT data. It is build on top of the NATS JetStream messaging system. It consists of:
1. Messaging Core, which is NATS JetStream.
2. Publisher Bindings which provide data sources.
3. Consumer Bindings for data delivery. This includes user interfaces and bindings to pass data to external processors.
4. Management Services for managing authentication, authorization, NATS configuration and other aspects.

This document describes a design of HiveOT using NATS JetStream.  

## Introduction

At its heart, HiveOT takes data from 'Things' and delivers it to interested consumers. It is based on the W3C WoT (Web of Things) standard. The WoT standard defines Things in a TD (Thing Description) document with their properties, events and actions. HiveOT considers all possible information sources as 'Things' and enables interaction with these Things through events and actions. 

Following the WoT standard, HiveOT uses two types of message flows: event flow and action flows. 

Event flow:

```
Thing[event] -> publisher -> router -> stream -> consumer
                                         |
                                       queue
```

Action flow:

```
Consumer[action] -> router -> stream -> publisher -> Thing
                                 |
                               queue
```

A description of the steps in these flows follows below. 

## Messages

Types of Messages:
* TD documents, which describe the source Thing with its properties, events and actions. 
* Events, are generated by Things that indicate something happened and can contain a payload.
* Actions, are provide by consumers or services to request something to happen on a Thing.

The information needed to deliver messages is provided in metadata, which includes: 
* the publisher of the message
* timestamp the message was created or published
* expiry of action messages
* destination for directed messages


## Publisher

Publishers connect to the messaging core and publish data in a WoT standard message format. They apply ETL (extract-transform-load) of the data to ensure WoT compatibility.    

Types of Publishers:
* IoT Devices manage one or more Things such as sensors and actuators
* Bindings translate between an IoT protocol and the WoT standard
* Services transform or generate information and publish the resulting events or actions  
* Consumers can publish actions to things

Each publisher has a unique persistent identifier used in authentication. Messages are accompanied by metadata that includes this publisher ID. To address an action message to a Thing, the publisher of that Thing must be known.

Each message is published on a topic, also called subject in NATS. The contains the information needed for message delivery.

event topic:
> things.{publisherID}.{thingID}.event.{type}

Where
* '.' is the NATS separator. MQTT uses '/'
* things is the standard prefix indicating this is a message about things
* {publisherID} is the authenticated ID of the publisher of the event. This can be the ID of an IoT device or a service producing events. 
* {thingID} is the unique ID of the IoT device producing the event. A publisher can publish one or more Things.  
* 'event' is the keyword to indicate the message is an event
* {type} describes the content of the message. A few types are predefined. Predefined vocabulary types have a $ prefix.
  * $td: event contains the TD document describing a thing
  * $properties: event contains the map of Thing Properties
  * temperature: event contains the temperature value 
  * humidity: ...
  * switch: ...

The use of vocabulary types is intended to simplify the processing and consumption of events. Events can be sorted and filtered based on the topic. The full list of vocabulary words can be found in vocabulary.md. It is the responsibility of the publisher to publish topics using the vocabulary standard.

NOTE: published subjects are not necessarily the same as subjects for subscription. Events are processed and stored in group queues which have a different topic. See the section consumers for more details.   

NOTE2: See also the section authentication on how to connect to the messaging core. 

## Router

The router maps published Things to the groups that have access to the Thing. HiveOT uses a role based access groups to manage authorized access to published messages. 

NATS streams are used to represent groups. It enables subscription, storage, lifecycle management, and filtering of group events. The authorization service converts the HiveOT group definition into subject mapping and streams.

The group mapping replaces the 'things' prefix of a topic to that of a group. For example, Things with sensors in the hydrologists group are mapped from:
> things.*.*.event.$waterlevel

to:
> hydrologists.*.*.event.$waterlevel

Consumers in the hydrologists group can subscribe to the hydrologists group on subject:
> hydrologists.>

When consumers receive events from this group the original topic remains intact and it is clear which group the event came from.

Any events that are not mapped to a group are part of the default 'things' group. 

As NATS streams doesn't support 1-many mapping of topics, a 'Thing' can only be added to a single group at a time. The use of 'mirrors' might be a way around this restriction. This is to be investigated.




## Stream 

Streams are message stores for delivery to its subscribers. Each stream represents a group with members as described in the router topic. 

The HiveOT authorization service that manages the groups defines the streams of the group. 

Consumers are automatically subscribed to streams they are a member of, including their own stream.

## Consumer

Consumers automatically receive events from the streams they are a member of. No subscription is neccesary.

## Authentication

Producers and consumers must authenticate in order to receive and publish messages.

Authentication uses NATS authentication mechanism with loginID/password and JWT tokens.



## TBD

How to direct events from Devices to queue? 'stream sources'?
How to query the queue? eg get last 24 hours
How to get the latest current? use kv or object store?
How to setup group queues?


