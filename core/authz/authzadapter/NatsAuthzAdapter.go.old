package authzadapter

import (
	"github.com/hiveot/hub/api/go/authz"
	"github.com/hiveot/hub/core/authz/authzservice"
	"github.com/hiveot/hub/core/hubclient/natshubclient"
	"github.com/hiveot/hub/core/msgserver/natsserver"
	"github.com/nats-io/nats.go"
	"golang.org/x/exp/slog"
	"time"
)

// EventsIntakeStreamName all group streams use this stream as their source
const EventsIntakeStreamName = "$events"

// NatsAuthzAdapter applies authz groups to NATS JetStream streams.
// Each group has its own stream with a source for events of each thingID in that group.
//
// This:
// 1. Ensures the event ingress stream exist for use by group streams as source
// 2. Ensures the 'all' group exists that subscribes to all events
// 3. Manages group streams CRUD
// 4. Manages client authorization for creating stream consumers for group subscription
type NatsAuthzAdapter struct {
	aclStore  *authzservice.AclFileStore
	msgServer *natsserver.NatsNKeyServer
	js        nats.JetStreamContext
}

// AddGroup creates a new stream for the added group.
//
//	groupName will be the stream name
//	retention manages the lifecycle of events in the stream. 0 for indefinitely
func (svc *NatsAuthzAdapter) AddGroup(groupName string, retention time.Duration) error {
	slog.Info("AddGroup", "groupName", groupName)

	// return if the stream exists
	_, err := svc.js.StreamInfo(groupName)
	if err == nil {
		return nil
	}

	if retention <= 0 {
		retention = -1
	}

	// empty group has no sources yet and no subjects
	// a source will be added for each thing that is in the group
	// the 'all' group has a source of all events.
	sources := make([]*nats.StreamSource, 0)
	if groupName == authz.AllGroupName {
		subject := natshubclient.MakeSubject("", "", natshubclient.SubjectTypeEvent, "")
		sources = append(sources, &nats.StreamSource{
			Name:          EventsIntakeStreamName,
			FilterSubject: subject,
		})
	}

	cfg := &nats.StreamConfig{
		Name:             groupName,
		Description:      "HiveOT Group",
		Retention:        nats.LimitsPolicy,
		Template:         "",
		Sources:          sources,
		SubjectTransform: nil,
		// overlapping subjects is not supported so use sources instead
		//Subjects:         []string{"things.publisherID.thingID.event.>"},
		MaxAge: retention,
	}
	strmInfo, err := svc.js.AddStream(cfg)
	if err != nil {
		return err
	}
	_ = strmInfo
	return err
}

//func (svc *NatsAuthzAdapter) AddService(serviceID string, groupName string) error {
//	//return fmt.Errorf("not yet implemented")
//	// todo: access control for the service. Not sure how.
//	return nil
//}

// AddThing adds the thing's subject as a stream source
//func (svc *NatsAuthzAdapter) AddThing(thingID string, groupName string) error {
//	slog.Info("AddThing",
//		slog.String("thingID", thingID),
//		slog.String("groupName", groupName),
//	)
//	// TODO: protect against duplicates
//	streamInfo, err := svc.js.StreamInfo(groupName)
//	if err != nil {
//		return fmt.Errorf("AddThing adding thing '%s' to group '%s' failed: %w",
//			thingID, groupName, err)
//	}
//	thingSubject := natshubclient.MakeSubject("", thingID, "event", "")
//	// the 'EventsIntakeStreamName' stream receives all events
//	newSource := &nats.StreamSource{
//		Name:          EventsIntakeStreamName,
//		FilterSubject: thingSubject,
//	}
//	streamInfo.Config.Sources = append(streamInfo.Config.Sources, newSource)
//	newInfo, err := svc.js.UpdateStream(&streamInfo.Config)
//	_ = newInfo
//	return err
//}
//func (svc *NatsAuthzAdapter) AddUser(userID string, role string, groupName string) (err error) {
//	// todo: access control for the service. Not sure how.
//	// user has permission to create an ephemeral consumer for this stream
//
//	//
//	subjects := svc.createAclRules(userID)
//	err = svc.msgServer.SetAclRules(userID, subjects)
//	return err
//}

//// create the subjects the user is authorized for based on group membership
//func (svc *NatsAuthzAdapter) createAclRules(userID string) []string {
//	rules := make([]string, 0)
//	roles, _ := svc.aclStore.GetClientRoles(userID)
//	for groupName, role := range roles {
//		readSubj := "$JS.API.CONSUMER.CREATE." + groupName
//		rules = append(rules, readSubj)
//
//		// TODO: operators and managers can publish actions for all things in the group
//		// Can we use a stream publish that mapped back to the thing?
//		// eg: {groupName}.{publisher}.{thing}.action.>
//		// maps to things.{publisher}.{thing}.action.>
//		// where the stream has a filter on all things added to the stream?
//		if role == authz.GroupRoleOperator || role == authz.GroupRoleManager {
//			actionSubj := groupName + ".*.*.action.>"
//			rules = append(rules, actionSubj)
//		}
//	}
//	return rules
//}

func (svc *NatsAuthzAdapter) DeleteGroup(groupName string) error {
	slog.Info("DeleteGroup", "groupName", groupName)
	err := svc.js.DeleteStream(groupName)
	return err
}

//func (svc *NatsAuthzAdapter) ListGroups(clientID string) (groups []authz.Group, err error) {
//	names := svc.js.StreamNames()
//	groups = make([]authz.Group, 0, len(names))
//	for name := range names {
//		groups = append(groups, authz.Group{Name: name})
//	}
//	return groups, err
//}

// RemoveThing removes a thing as a stream source
func (svc *NatsAuthzAdapter) RemoveThing(clientID string, groupName string) error {
	// remove things
	slog.Info("RemoveThing",
		slog.String("clientID", clientID),
		slog.String("groupName", groupName),
	)
	sInfo, err := svc.js.StreamInfo(groupName)
	if err != nil {
		return err
	}
	// remove clientID as a source of a thing
	// each source is a thing
	sources := sInfo.Config.Sources
	for i, s := range sources {
		// thing IDs are in the filter subject of the source
		_, thingID, _, _, _ := natshubclient.SplitSubject(s.FilterSubject)
		if thingID == clientID {
			sources[i] = sources[len(sources)-1]
			sources = sources[:len(sources)-1]
			break
		}
	}
	_, err = svc.js.UpdateStream(&sInfo.Config)
	return err
}

// RemoveThingAll a Thing as a source from all its streams
func (svc *NatsAuthzAdapter) RemoveThingAll(clientID string) error {
	names := svc.js.StreamNames()
	for name := range names {
		err := svc.RemoveThing(clientID, name)
		if err != nil {
			return err
		}
	}
	slog.Info("RemoveThingAll",
		slog.String("clientID", clientID),
	)
	return nil
}

//// Start synchronizes the authorization groups with the JetStream configuraiton
//func (svc *NatsAuthzAdapter) Start() error {
//	return fmt.Errorf("not yet implemented")
//}
//
//func (svc *NatsAuthzAdapter) Stop() {
//}

// Start ensures the '$events' stream exists to receive all events and applies
// authorization settings to users.
func (svc *NatsAuthzAdapter) Start() error {
	nc1, err := svc.msgServer.ConnectInProc("authz", nil)
	if err != nil {
		return err
	}
	hc1, err := natshubclient.ConnectWithNC(nc1, "authz")
	if err != nil {
		return err
	}
	svc.js = hc1.JS()

	// ensure the events intake stream exists
	_, err = svc.js.StreamInfo(EventsIntakeStreamName)
	if err != nil {
		// The intake stream receives events from all publishers and things
		subj := natshubclient.MakeSubject("", "", natshubclient.SubjectTypeEvent, ">")
		cfg := &nats.StreamConfig{
			Name:        EventsIntakeStreamName,
			Description: "HiveOT Events Intake Stream",
			Retention:   nats.LimitsPolicy,
			Subjects:    []string{subj},
			// since consumers are other streams, a short retention should suffice
			MaxAge: time.Hour,
		}
		_, err = svc.js.AddStream(cfg)
	}

	// apply authorization settings to existing users
	//for _, userID := range svc.aclStore.users {
	//
	//	subjects := svc.createAclRules(userID)
	//	err = svc.msgServer.SetAclRules(userID, subjects)
	//
	//}
	return err
}

func (svc *NatsAuthzAdapter) Stop() {
}

// NewNatsAuthzAdapter applies authz to NATS JetStream streams
// This implements the IAuthz interface
func NewNatsAuthzAdapter(aclStore *authzservice.AclFileStore, msgServer *natsserver.NatsNKeyServer) *NatsAuthzAdapter {
	svc := &NatsAuthzAdapter{
		aclStore:  aclStore,
		msgServer: msgServer,
	}
	return svc
}
