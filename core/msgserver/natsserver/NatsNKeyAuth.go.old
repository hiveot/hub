package natsserver

// AddDevice adds a IoT device authn key to the app account and reloads the options.
// Devices can pub/sub on their own subject, eg: things.{deviceID}.>
//func (srv *NatsNKeyServer) AddDevice(deviceID string, deviceKeyPub string) error {
//	// if callout has been activated then exclude the key from invoking callout
//	if srv.natsOpts.AuthCallout != nil {
//		srv.natsOpts.AuthCallout.AuthUsers = append(srv.natsOpts.AuthCallout.AuthUsers, deviceKeyPub)
//	}
//
//	appAcct, err := srv.ns.LookupAccount(srv.cfg.AppAccountName)
//	if err != nil {
//		return fmt.Errorf("missing app account: %w", err)
//	}
//	srv.natsOpts.Nkeys = append(srv.natsOpts.Nkeys, &server.NkeyUser{
//		Nkey:    deviceKeyPub,
//		Account: appAcct,
//	})
//	err = srv.ns.ReloadOptions(&srv.natsOpts)
//	return err
//}
//
//// AddService adds a core service authn key to the app account and reloads the options.
//// Services can pub/sub to all things subjects
//func (srv *NatsNKeyServer) AddService(serviceID string, serviceKeyPub string) error {
//	// if callout has been activated then exclude the key from invoking callout
//	if srv.natsOpts.AuthCallout != nil {
//		srv.natsOpts.AuthCallout.AuthUsers = append(srv.natsOpts.AuthCallout.AuthUsers, serviceKeyPub)
//	}
//
//	appAcct, err := srv.ns.LookupAccount(srv.cfg.AppAccountName)
//	if err != nil {
//		return fmt.Errorf("missing app account: %w", err)
//	}
//	srv.natsOpts.Nkeys = append(srv.natsOpts.Nkeys, &server.NkeyUser{
//		Nkey:    serviceKeyPub,
//		Account: appAcct,
//	})
//	err = srv.ns.ReloadOptions(&srv.natsOpts)
//	return err
//}
//
//// AddUser adds a user login/pw to the app account and reloads the options.
//// Users can pub to inboxes
//func (srv *NatsNKeyServer) AddUser(userID string, password string, userKeyPub string) error {
//	// if callout has been activated then exclude the key from callout
//	if srv.natsOpts.AuthCallout != nil && userKeyPub != "" {
//		srv.natsOpts.AuthCallout.AuthUsers = append(srv.natsOpts.AuthCallout.AuthUsers, userKeyPub)
//	}
//
//	appAcct, err := srv.ns.LookupAccount(srv.cfg.AppAccountName)
//	if err != nil {
//		return fmt.Errorf("missing app account: %w", err)
//	}
//	if userKeyPub != "" {
//		srv.natsOpts.Nkeys = append(srv.natsOpts.Nkeys, &server.NkeyUser{
//			Nkey:        userKeyPub,
//			Account:     appAcct,
//			Permissions: noAuthPermissions,
//			// todo: permissions
//		})
//	}
//	if password != "" {
//		srv.natsOpts.Users = append(srv.natsOpts.Users, &server.User{
//			Username:    userID,
//			Password:    password,
//			Permissions: nil, // TODO
//			Account:     appAcct,
//		})
//	}
//	err = srv.ns.ReloadOptions(&srv.natsOpts)
//	return err
//}

// SetAclRules sets the subjects the clientID has access to.
//func (srv *NatsNKeyServer) SetAclRules(clientID string, subjects []string) error {
//	subjectPerm := server.SubjectPermission{
//		Allow: subjects,
//		Deny:  nil,
//	}
//	newPermissions := server.Permissions{
//		Publish:   nil,
//		Subscribe: &subjectPerm,
//		Response:  nil,
//	}
//	for _, user := range srv.natsOpts.Users {
//		if clientID == user.Username {
//			user.Permissions = &newPermissions
//			break
//		}
//	}
//	return nil
//}

// UpdateKey changes the public key of a user login and reload options
// This fails if oldKey doesn't exist. The caller should have added it first to ensure proper permissions
// This returns an error if the old key is not found
//
// WARNING: changing the public key of the connected account can cause an authentication failure when
// sending the reply. The workaround is to delay the reload.
//func (srv *NatsNKeyServer) UpdateKey(oldKey string, newKey string) error {
//	for _, n := range srv.natsOpts.Nkeys {
//		if n.Nkey == oldKey {
//			n.Nkey = newKey
//			// sending a reply after changing the key of the caller causes an authentication error
//			// therefore apply after returning
//			go func() {
//				_ = srv.ns.ReloadOptions(&srv.natsOpts)
//			}()
//			return nil
//		}
//	}
//	return fmt.Errorf("can't update key  '%s' is not found", oldKey)
//}
//
//// UpdatePassword changes the password of a user login and reload options
//// This returns an error if the user is not found
//func (srv *NatsNKeyServer) UpdatePassword(userID string, password string) error {
//	for _, u := range srv.natsOpts.Users {
//		if u.Username == userID {
//			u.Password = password
//			err := srv.ns.ReloadOptions(&srv.natsOpts)
//			return err
//		}
//	}
//	return fmt.Errorf("can't update password as user '%s' is not found", userID)
//}
